#!/usr/bin/env bash

set -e

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging

source $(dirname $0)/common.sh

source=$1
if [ -z "$source" ]; then
  echo "usage: $0 <path/to/source>" >&2
  exit 1
fi

payload=$(mktemp /tmp/artifactory-deb.XXXXXX)
cat > $payload <&0

assemble_properties() {
  echo "deb.component=$component;deb.distribution=$distribution;deb.architecture=$architecture"
}

assemble_url() {
  local deb=$1
  echo "$repository/$components_dir/$deb;$(assemble_properties)"
}

put() {
  local deb=$1
  local url="$(assemble_url $deb)"

  echo "Publishing $url"
  curl -L --fail -u$username:$password -XPUT -T $deb $url || exit 1
}

version_for() {
  local deb=$1
  dpkg-deb -I $deb | grep Version | awk '{print $2}'
}

extract_version_from_deb() {
  local main_deb=$(ls *.deb | egrep "^${package}_.*")
  if [ -z "$main_deb" ]; then
    echo "A 'version' parameter was not supplied, and a deb archive '${package}_<version>.deb', from which a version can be extracted, could not be found." >&2
    exit 1
  fi
  version_for $main_deb
}

resolve_version() {
  local version_dir=$(jq -r '.params.version // ""' < $payload)
  if [ -n "$version_dir" ]; then
    local version_file="${source}/${version_dir}/number"
    local version=$(cat $version_file)
    test -z "$version" && { echo "version not found in $version_file"; exit 1; }
  else
    local version=$(extract_version_from_deb)
  fi

  echo $version
}

repository=$(attr source repository)
username=$(attr source username)
password=$(attr source password)
package=$(attr source package)
distribution=$(attr source distribution)
debs=$(attr params debs)

component=$(jq -r '.source.component // "main"' < $payload)
components_dir=$(jq -r '.source.components_dir // "pool"' < $payload)
architecture=$(jq -r '.source.architecture // "amd64"' < $payload)

cd $source/$debs

version=$(resolve_version)

for f in $(ls *.deb); do
  put $f
done

jq -n "{
  version: {
    number: \"$version\"
  }
}" >&3
